#############################
# Tarasov 2018
# Onto-phylo project
# ASR Hymenoptera
#
#############################

#######################
# Reading in the Data #
#######################

# names to declare
analysis_name = "CHAR:239"
#"CHAR:239_"
# these entities must contain directories
# i.e. "/home/tarasov/Documents/RevBayes/hmm_dpp/alces_run/mny_runs/two-st-tree.tre"
tree_2_read= "data/Hymenoptera_br_resolved.tre"
#"@tree_2_read@"
#"data/Hymenoptera_br_resolved.tre"
chrs_2_read= "data/CHAR:239.char"
#"data/Hym-char239-1.nex"

# variables to be predifined in this template
mcmc_gen = 5000000
#burnin_gen = 2000
log_freq = 100

#seed(2555)

# moves and monitors
mvi = 0
mni = 0

# variable obtained from scipt
NUM_STATES = 4
# arg of readCharacterDataDelimited()
#CHAR_stateLabels= "@CHAR_stateLabels@"

# Read in the character data
char_data = readCharacterDataDelimited(chrs_2_read, type="NaturalNumbers", delimiter=" ", stateLabels = NUM_STATES, headers=false)
# Read in tree
psi = readTrees(tree_2_read)[1]

#map_tree = readTrees("data/Hym_tree_sp-selected.tre")[1]
#map_tree = readBranchLengthTrees("data/precooked_MAP.tree")[1]


#######################
# Character Evolution Model
#######################

# declare rate matrix
for (i in 1:NUM_STATES) {
  for (j in 1:NUM_STATES) {
    rates[i][j] <-0.0
  }
}

# lamda parameter of Exp distribution that is prior for Q matrix rates
lambda_pr := 10

##### Uniform hyperprior
r1 ~ dnExp(100)
r2 ~ dnExp(100)
r3 ~ dnExp(100)
r4 ~ dnExp(100)

#####


########### different priors for different rates
# number of r elements is equal to the number of rate categories
#r1 ~ dnExp(300)
#r2 ~ dnExp(3000)
#r3 ~ dnExp(3000)
#r4 ~ dnExp(3000)
############################

moves[++mvi] = mvScale(r1,lambda=0.2,tune=true,weight=2)
moves[++mvi] = mvScale(r2,lambda=0.2,tune=true,weight=2)
moves[++mvi] = mvScale(r3,lambda=0.2,tune=true,weight=2)
moves[++mvi] = mvScale(r4,lambda=0.2,tune=true,weight=2)


# place rate categories into matrix
rates[3][1]:=r2
rates[4][2]:=r2
rates[1][3]:=r1
rates[4][3]:=r4
rates[2][4]:=r1
rates[3][4]:=r3

#make rate matrix
rate_matrix := fnFreeK(rates, rescaled=false)

##
# Set up the root state frequencies #
##################################
### Create a constant variable with the prior probabilities of each rate category at the root.
#root_freq~ dnDirichlet( rep(1, NUM_STATES) )
#moves[++mvi] = mvBetaSimplex(root_freq, tune=true, weight=2)
#moves[++mvi] = mvDirichletSimplex(root_freq, tune=true, weight=2)

root_freq <- simplex(1,1,1,1)

###############
# create the model
###############
morpho_ctmc ~ dnPhyloCTMC(Q=rate_matrix, tree=psi, rootFreq=root_freq, branchRates=1.0, type="NaturalNumbers")

# clamp data
morpho_ctmc.clamp(char_data)

### workspace model wrapper ###
mymodel = model(rate_matrix)

# create the monitors
# model param to file monitor
monitors[++mni] = mnModel(filename="output/" + analysis_name + "param.log", printgen=log_freq)
# model param to screen monitor
monitors[++mni] = mnScreen(printgen=log_freq)
# tree monitor fro treetrace awith Stocj mapping
#monitors[++mni] = mnFile(filename="output/mk1.trees", printgen=10, psi)
#monitors[++mni] = mnJointConditionalAncestralState(filename="output/" + analysis_name + "ans.log", printgen=log_freq, tree=psi, ctmc=morpho_ctmc, type="NaturalNumbers")
# Stoch mapping monitor
#monitors[++mni]= mnStochasticCharacterMap(ctmc=morpho_ctmc, filename="output/" + analysis_name + "stochm.log", printgen=log_freq)


###############
# run MCMC analysis
###############
mymcmc = mcmc(mymodel, monitors, moves, nruns=1, moveschedule="random")

### pre-burnin to tune the proposals
#mymcmc.burnin(generations=2000, tuningInterval=500)

### run the MCMC
mymcmc.run(mcmc_gen)

mymcmc.operatorSummary()

# set up mcmc... in a real analysis you'd want to run the chain longer and check for convergence...
#mymcmc = mcmc(mymodel, monitors, moves)
#mymcmc.run(mcmc_gen)

#mymcmc.operatorSummary()

#######################################3

# # now summarize ancestral states over the MAP tree
#ancestral_state_trace = readAncestralStateTrace("output/mk1.log")
#ancestral_state_tree_trace = readAncestralStateTreeTrace("output/mk1.trees", treetype="non-clock")
#ancestralStateTree(map_tree, ancestral_state_trace, ancestral_state_tree_trace, "output/mk1_final.tree")

# The ancestral state tree trace step is necessary because the ancestralStateTree function does not
# assume the topology is fixed.
#anc_state_trace = readAncestralStateTrace("output/Stoch_maps.log")
#characterMapTree(psi, anc_state_trace, num_time_slices=1000, character_file="output/character.tree", posterior_file="output/posterior.tree", burnin=20, reconstruction="marginal")


###############
# calculate Bayes factor
###############

# Compute power posterior distributions
#ss_monitors[1] = monitors[4]
#pow_p = powerPosterior(mymodel, moves, ss_monitors, "output/mk1.out", cats=10)
#pow_p.run(generations=1000)

# Use stepping-stone sampling to calculate marginal likelihoods
#ss = steppingStoneSampler(file="output/mk1.out", powerColumnName="power", likelihoodColumnName="likelihood")
#ss.marginal()

# This last line gives us the marginal log-likelihood (lnL) of the model. To compare the two models
# we will calculate the log-Bayes factor as such:
#
# ln-Bayes factor = ( marginal lnL of mk12 ) - ( marginal lnL of mk1 )
#
# Then we convert to the raw Bayes factor by taking the exponent:
#
# BF(mk12, mk1) = e ^ ( ln-Bayes factor )
#
# Calculate the Bayes factor after running both Part 1 and Part 2 of this tutorial. Which model of
# gynostemium evolution fits the data better? How do the reconstructed ancestral states differ?
# Both MCMC analyses ran for the same number of iterations. Did both converge to their stationary
# distribution? Implement another model of gynostemium evolution and compare it to mk1 and mk12.
# None of these models may be very realistic due to the way gynostemium morphology was initially
# coded. Suggest an alternative coding scheme.
