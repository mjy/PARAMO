#############################
# Tarasov 2018
# Onto-phylo project
# ASR Hymenoptera
#
#############################

#######################
# Reading in the Data #
#######################

# names to declare
analysis_name = "CHAR:239"
#"CHAR:239_"
# these entities must contain directories
# i.e. "/home/tarasov/Documents/RevBayes/hmm_dpp/alces_run/mny_runs/two-st-tree.tre"
tree_2_read= "data/Hymenoptera_br_resolved.tre"
#"@tree_2_read@"
#"data/Hymenoptera_br_resolved.tre"
chrs_2_read= "data/CHAR:239.char"
#"data/Hym-char239-1.nex"

# variables to be predifined in this template
mcmc_gen = 5000000
#burnin_gen = 2000
log_freq = 1000

#seed(2555)

# moves and monitors
mvi = 0
mni = 0

# variable obtained from scipt
NUM_STATES = 4
# arg of readCharacterDataDelimited()
#CHAR_stateLabels= "@CHAR_stateLabels@"

# Read in the character data
char_data = readCharacterDataDelimited(chrs_2_read, type="NaturalNumbers", delimiter=" ", stateLabels = NUM_STATES, headers=false)
# Read in tree
psi = readTrees(tree_2_read)[1]

#map_tree = readTrees("data/Hym_tree_sp-selected.tre")[1]
#map_tree = readBranchLengthTrees("data/precooked_MAP.tree")[1]


#######################
# Character Evolution Model
#######################

# declare rate matrix
for (i in 1:NUM_STATES) {
  for (j in 1:NUM_STATES) {
    rates[i][j] <-0.0
  }
}

# lamda parameter of Exp distribution that is prior for Q matrix rates
lambda_pr := 10

##### Uniform hyperprior
#hr1 ~ dnUniform(0, 100)
#hr2 ~ dnUniform(0, 100)
#hr3 ~ dnUniform(0, 100)
#hr4 ~ dnUniform(0, 100)

#r1 ~ dnExp(hr1)
#r2 ~ dnExp(hr2)
#r3 ~ dnExp(hr3)
#r4 ~ dnExp(hr4)
#####

#rate prior
r2 ~ dnExp(0.1)
r1 ~ dnExp(0.1)
r4 ~ dnExp(0.1)
r3 ~ dnExp(0.1)

########### different priors for different rates
# number of r elements is equal to the number of rate categories
#r1 ~ dnExp(300)
#r2 ~ dnExp(3000)
#r3 ~ dnExp(3000)
#r4 ~ dnExp(3000)
############################
moves[++mvi] = mvScale(r2, lambda=0.2, tune=true, weight=2)
moves[++mvi] = mvScale(r1, lambda=0.2, tune=true, weight=2)
moves[++mvi] = mvScale(r4, lambda=0.2, tune=true, weight=2)
moves[++mvi] = mvScale(r3, lambda=0.2, tune=true, weight=2)
#moves[++mvi] = mvScale(r1,lambda=0.2,tune=true,weight=2)
#moves[++mvi] = mvScale(r2,lambda=0.2,tune=true,weight=2)
#moves[++mvi] = mvScale(r3,lambda=0.2,tune=true,weight=2)
#moves[++mvi] = mvScale(r4,lambda=0.2,tune=true,weight=2)

#moves[++mvi] = mvSlide(hr1, tune=true,weight=2)
#moves[++mvi] = mvSlide(hr2, tune=true,weight=2)
#moves[++mvi] = mvSlide(hr3, tune=true,weight=2)
#moves[++mvi] = mvSlide(hr4, tune=true,weight=2)

rates[3][1]:=r2
rates[4][2]:=r2
rates[1][3]:=r1
rates[4][3]:=r4
rates[2][4]:=r1
rates[3][4]:=r3
# place rate categories into matrix
#rates[3][1]:=r2
#rates[4][2]:=r2
#rates[1][3]:=r1
#rates[4][3]:=r4
#rates[2][4]:=r1
#rates[3][4]:=r3

#make rate matrix
rate_matrix := fnFreeK(rates, rescaled=false)

##
# Set up the root state frequencies #
##################################
### Create a constant variable with the prior probabilities of each rate category at the root.
#root_freq~ dnDirichlet( rep(1, NUM_STATES) )
#moves[++mvi] = mvBetaSimplex(root_freq, tune=true, weight=2)
#moves[++mvi] = mvDirichletSimplex(root_freq, tune=true, weight=2)

root_freq <- simplex(1,1,1,1)

###############
# create the model
###############
morpho_ctmc ~ dnPhyloCTMC(Q=rate_matrix, tree=psi, rootFreq=root_freq, branchRates=1.0, type="NaturalNumbers")

# clamp data
morpho_ctmc.clamp(char_data)

### workspace model wrapper ###
mymodel = model(rate_matrix)

# create the monitors
# model param to file monitor
monitors[++mni] = mnModel(filename="output/" + analysis_name + "_param.log", printgen=log_freq)
# model param to screen monitor
monitors[++mni] = mnScreen(printgen=log_freq)
# tree monitor fro treetrace awith Stocj mapping
#monitors[++mni] = mnFile(filename="output/mk1.trees", printgen=10, psi)
monitors[++mni] = mnJointConditionalAncestralState(filename="output/" + analysis_name + "_ans.log", printgen=log_freq, tree=psi, ctmc=morpho_ctmc, type="NaturalNumbers")
# Stoch mapping monitor
monitors[++mni]= mnStochasticCharacterMap(ctmc=morpho_ctmc, filename="output/" + analysis_name + "_stochm.log", printgen=log_freq)


###############
# run MCMC analysis
###############
mymcmc = mcmc(mymodel, monitors, moves, nruns=1, moveschedule="random")

### pre-burnin to tune the proposals
mymcmc.burnin(generations=50000, tuningInterval=1000)

### run the MCMC
mymcmc.run(mcmc_gen)

mymcmc.operatorSummary()

# set up mcmc... in a real analysis you'd want to run the chain longer and check for convergence...
#mymcmc = mcmc(mymodel, monitors, moves)
#mymcmc.run(mcmc_gen)

#mymcmc.operatorSummary()

#######################################

# # now summarize ancestral states over the MAP tree
#ancestral_state_trace = readAncestralStateTrace("output/mk1.log")
#ancestral_state_tree_trace = readAncestralStateTreeTrace("output/mk1.trees", treetype="non-clock")
#ancestralStateTree(map_tree, ancestral_state_trace, ancestral_state_tree_trace, "output/mk1_final.tree")

# The ancestral state tree trace step is necessary because the ancestralStateTree function does not
# assume the topology is fixed.
#anc_state_trace = readAncestralStateTrace("output/Stoch_maps.log")
#characterMapTree(psi, anc_state_trace, num_time_slices=1000, character_file="output/character.tree", posterior_file="output/posterior.tree", burnin=20, reconstruction="marginal")
